# ==== 1. 导入基础库 ====
import argparse
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
import shap

# 字体设置（支持中文）
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False


# ==== 2. 主函数 ====
def main(input_path, target_col, output_dir):
    # ---------- 读取数据 ----------
    print(f"📘 正在读取数据文件：{input_path}")
    if input_path.endswith(".xlsx") or input_path.endswith(".xls"):
        df = pd.read_excel(input_path)
    elif input_path.endswith(".csv"):
        df = pd.read_csv(input_path)
    else:
        raise ValueError(" 仅支持 Excel 或 CSV 文件！")

    print(f"数据读取成功，维度：{df.shape}")

    # ---------- 特征与目标 ----------
    if target_col not in df.columns:
        raise ValueError(f" 目标列 '{target_col}' 不存在！可选列有：{list(df.columns)}")

    X = df.drop(columns=[target_col])
    y = df[target_col]

    # 保留数值型变量
    X = X.select_dtypes(include=[np.number])
    print(f"数值特征数：{X.shape[1]}")

    # ---------- 数据集划分 ----------
    X_temp, X_test, y_temp, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    X_train, X_val, y_train, y_val = train_test_split(X_temp, y_temp, test_size=0.125, random_state=24)

    # ---------- 标准化 ----------
    x_mean, x_std = X_train.mean(), X_train.std()
    y_mean, y_std = y.mean(), y.std()
    X_train = (X_train - x_mean) / x_std
    X_val = (X_val - x_mean) / x_std
    X_test = (X_test - x_mean) / x_std
    y_train = (y_train - y_mean) / y_std
    y_val = (y_val - y_mean) / y_std
    y_test = (y_test - y_mean) / y_std

    # ---------- 构建模型 ----------
    model_rf = RandomForestRegressor(
        n_estimators=200,
        max_depth=None,
        random_state=42,
        n_jobs=-1
    )
    print("🚀 模型开始训练...")
    model_rf.fit(X_train, y_train)

    # ---------- 预测 ----------
    pred_train = model_rf.predict(X_train)
    pred_val = model_rf.predict(X_val)
    pred_test = model_rf.predict(X_test)

    # ---------- 反标准化 ----------
    y_train_h = y_train * y_std + y_mean
    y_val_h = y_val * y_std + y_mean
    y_test_h = y_test * y_std + y_mean
    pred_train_h = pred_train * y_std + y_mean
    pred_val_h = pred_val * y_std + y_mean
    pred_test_h = pred_test * y_std + y_mean

    # ---------- 性能评估 ----------
    def print_metrics(y_true, y_pred, dataset_name="数据集"):
        r2 = r2_score(y_true, y_pred)
        rmse = np.sqrt(mean_squared_error(y_true, y_pred))
        mae = mean_absolute_error(y_true, y_pred)
        print(f"\n {dataset_name}指标:")
        print(f"  R² = {r2:.3f}")
        print(f"  RMSE = {rmse:.3f}")
        print(f"  MAE = {mae:.3f}")
        return {"R2": r2, "RMSE": rmse, "MAE": mae}

    metrics = {
        "Train": print_metrics(y_train_h, pred_train_h, "训练集"),
        "Validation": print_metrics(y_val_h, pred_val_h, "验证集"),
        "Test": print_metrics(y_test_h, pred_test_h, "测试集")
    }

    # ---------- 绘制真实 vs 预测 ----------
    def plot_pred_vs_true(y_true, y_pred, dataset_name, color):
        r2 = r2_score(y_true, y_pred)
        rmse = np.sqrt(mean_squared_error(y_true, y_pred))
        mae = mean_absolute_error(y_true, y_pred)
        plt.scatter(y_true, y_pred, alpha=0.3, color=color, label=f'{dataset_name}')
        plt.xlabel('真实值')
        plt.ylabel('预测值')
        plt.title(f'{dataset_name}：R²={r2:.3f}, RMSE={rmse:.3f}, MAE={mae:.3f}')
        plt.legend()
        min_val, max_val = min(y_true.min(), y_pred.min()), max(y_true.max(), y_pred.max())
        plt.plot([min_val, max_val], [min_val, max_val], 'k--', alpha=0.5)

    plt.figure(figsize=(15, 15), dpi=300)
    colors = sns.color_palette("husl", 3)
    plt.subplot(3, 1, 1)
    plot_pred_vs_true(y_train_h, pred_train_h, "训练集", colors[0])
    plt.subplot(3, 1, 2)
    plot_pred_vs_true(y_val_h, pred_val_h, "验证集", colors[1])
    plt.subplot(3, 1, 3)
    plot_pred_vs_true(y_test_h, pred_test_h, "测试集", colors[2])
    plt.tight_layout()

    scatter_path = os.path.join(output_dir, f"{target_col}_预测对比图.png")
    plt.savefig(scatter_path, dpi=300)
    plt.close()
    print(f" 预测对比图已保存到：{scatter_path}")

    # ---------- SHAP 分析 ----------
    print(" 正在计算 SHAP 值（可能需要一些时间）...")
    explainer = shap.TreeExplainer(model_rf)
    shap_values_test = explainer.shap_values(X_test)

    # 点图
    shap.summary_plot(shap_values_test, X_test, feature_names=X_test.columns, plot_type="dot", show=False)
    dot_path = os.path.join(output_dir, f"{target_col}_SHAP_dot.png")
    plt.savefig(dot_path, dpi=300, bbox_inches="tight")
    plt.close()

    # 柱状图
    shap.summary_plot(shap_values_test, X_test, plot_type="bar", show=False)
    bar_path = os.path.join(output_dir, f"{target_col}_SHAP_bar.png")
    plt.savefig(bar_path, dpi=300, bbox_inches="tight")
    plt.close()

    print(f" SHAP 图已保存到：{dot_path} 和 {bar_path}")

    # ---------- 保存指标 ----------
    metric_df = pd.DataFrame(metrics).T
    metric_path = os.path.join(output_dir, f"{target_col}_模型评估指标.xlsx")
    metric_df.to_excel(metric_path)
    print(f"📄 模型评估指标已保存到：{metric_path}")

    print("\n 全部分析完成！结果已输出至：", output_dir)


# ==== 3. 参数接口 ====
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="通用随机森林回归 + SHAP 解释")
    parser.add_argument("--input", required=True, help="输入文件路径（Excel 或 CSV）")
    parser.add_argument("--target", required=True, help="目标列名（回归预测变量）")
    parser.add_argument("--output_dir", required=True, help="输出文件夹路径")
    args = parser.parse_args()

    os.makedirs(args.output_dir, exist_ok=True)
    main(args.input, args.target, args.output_dir)
